# 数据管理模块（函数式版本）
import numpy as np
import pandas as pd
import scipy.io

from 日志管理 import 日志记录器


def 规范数据标识(入库流量, 需水量, 初始库容, 最小库容, 最大库容, 最大泄流量, 损失量,
                 库容时序=None, 归一化入库流量=None, 归一化需水量=None,
                 归一化损失量=None, 归一化参数=None):
    return {
        "原始数据": {
            "入库流量": 入库流量,
            "需水量": 需水量,
            "初始库容": 初始库容,
            "最小库容": 最小库容,
            "最大库容": 最大库容,
            "最大泄流量": 最大泄流量,
            "损失量": 损失量
        },
        "时序数据": {
            "动态库容时序": 库容时序
        },
        "归一化数据": {
            "入库流量": 归一化入库流量,
            "需水量": 归一化需水量,
            "损失量": 归一化损失量,
            "参数": 归一化参数
        }
    }


# 核心函数
def 验证配置参数(配置参数):
    if "数据长度" not in 配置参数:
        raise ValueError("配置参数中缺少 数据长度")
    if 配置参数["数据长度"] not in [60, 240, 480]:
        raise ValueError(f"无效的数据长度: {配置参数['数据长度']}")


def 计算库容时序(初始库容, 入库流量,损失量,配置最小库容, 配置最大库容):
    """
    计算动态库容时序，基于入库流量、损失量等数据
    假设 release = 0.6 * inflow
    """
    入库流量 = 入库流量.flatten()
    损失量 = 损失量.flatten()
    数据长度 = len(入库流量)

    库容序列 = np.zeros(数据长度)
    库容序列[0] = 初始库容

    for 时刻 in range(1, 数据长度):
        泄流量 = 0.6 * 入库流量[时刻]
        库容序列[时刻] = 库容序列[时刻 - 1] + 入库流量[时刻] - 泄流量 - 损失量[时刻]
        库容序列[时刻] = np.clip(库容序列[时刻], 配置最小库容, 配置最大库容)

    return 库容序列


def 加载原始数据(数据路径:str, MAT变量列表:list[str],数据长度:int,配置最小库容:float,配置最大库容:float):
    """从MAT文件加载原始数据"""
    mat数据 = scipy.io.loadmat(数据路径)
    日志记录器.info("实际加载的键名: %s", list(mat数据.keys()))

    有效数据 = {}
    for 变量名 in MAT变量列表:
        if 变量名 in mat数据:
            有效数据[变量名] = mat数据[变量名]

    # 计算库容时序
    有效数据["库容时序"] = 计算库容时序(有效数据["S_initial"],
                                        有效数据[f"Inflow{数据长度}"],
                                        有效数据[f"Loss{数据长度}"],
                                        配置最小库容,配置最大库容)

    return 有效数据


def 提取标量参数(原始数据, 参数名):
    """安全提取标量参数"""
    候选名 = [参数名, 参数名.title()]
    for 名称 in 候选名:
        if 名称 in 原始数据:
            值 = 原始数据[名称]
            if isinstance(值, np.ndarray):
                # 将单元素数组转为Python标量
                return 值.item()
            else:
                return 值
    raise KeyError(f"参数 {参数名} 不存在于原始数据中")


def 归一化处理(数据序列):
    """最小-最大归一化"""
    最小值 = np.min(数据序列)
    最大值 = np.max(数据序列)
    if 最大值 - 最小值 == 0:
        return 数据序列, 最小值, 最大值
    归一化数据 = (数据序列 - 最小值) / (最大值 - 最小值)
    return 归一化数据, 最小值, 最大值


def 预处理数据(原始数据, 数据长度,配置最小库容, 配置最大库容):
    """数据预处理管道"""
    # 1. 提取静态参数
    静态参数 = {
        "初始库容": 提取标量参数(原始数据, "S_initial"),
        "最小库容": 提取标量参数(原始数据, "S_min"),
        "最大库容": 提取标量参数(原始数据, "S_max"),
        "最大泄流量": 提取标量参数(原始数据, "D_max")
    }

    # 处理最大泄流量为序列
    数据长度 = 数据长度
    # 如果……？
    if isinstance(静态参数["最大泄流量"], (int, float)):
        静态参数["最大泄流量"] = np.full(数据长度, 静态参数["最大泄流量"])
    elif len(静态参数["最大泄流量"]) != 数据长度:
        静态参数["最大泄流量"] = np.resize(静态参数["最大泄流量"], 数据长度)

    # 2. 提取动态时序数据
    动态数据 = {}
    for 变量前缀 in ["Inflow", "Demand", "Loss"]:
        变量名 = f"{变量前缀}{数据长度}"
        if 变量名 not in 原始数据:
            raise KeyError(f"缺少变量: {变量名}")
        动态数据[变量前缀.lower()] = 原始数据[变量名].flatten()

    # 3. 数据归一化
    归一化结果 = {}
    for 变量名 in ["inflow", "demand", "loss"]:
        归一化序列, 最小值, 最大值 = 归一化处理(动态数据[变量名])
        归一化结果[f"{变量名}_norm"] = 归一化序列
        归一化结果[f"{变量名}_params"] = {"min": 最小值, "max": 最大值}

    # 4. 计算库容时序 动态数据["inflow"]=入库流量 动态数据["loss"]=损失量
    库容时序 = 计算库容时序(静态参数["初始库容"], 动态数据["inflow"], 动态数据["loss"], 配置最小库容, 配置最大库容)

    # 记录日志
    日志记录器.info(
        "需水量数据统计：均值=%.2f, 最大值=%.2f",
        np.mean(动态数据["demand"]),
        np.max(动态数据["demand"])
    )

    # 返回数据容器
    return 规范数据标识(
        入库流量=动态数据["inflow"],
        需水量=动态数据["demand"],
        初始库容=静态参数["初始库容"],
        最小库容=静态参数["最小库容"],
        最大库容=静态参数["最大库容"],
        最大泄流量=静态参数["最大泄流量"],
        损失量=动态数据["loss"],
        库容时序=库容时序,
        归一化入库流量=归一化结果["inflow_norm"],
        归一化需水量=归一化结果["demand_norm"],
        归一化损失量=归一化结果["loss_norm"],
        归一化参数={
            "inflow": 归一化结果["inflow_params"],
            "demand": 归一化结果["demand_params"],
            "loss": 归一化结果["loss_params"]
        }
    )


def 插值填补缺失值(数据序列):
    """线性插值填补缺失数据"""
    return pd.Series(数据序列).interpolate(method="linear").ffill().bfill().values


# 主入口函数
def 获取处理后的数据(配置参数):
    """数据管理主流程"""
    验证配置参数(配置参数)
    原始数据 = 加载原始数据(配置参数["数据路径"], 配置参数)
    return 预处理数据(原始数据, 配置参数)